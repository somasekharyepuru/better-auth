generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Better Auth Core Tables

model User {
  id            String      @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  twofactors    TwoFactor[]

  // Additional fields
  role String? @default("user")

  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  // Organization relations
  members Member[]

  twoFactorEnabled Boolean?     @default(false)
  invitations      Invitation[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  // Organization fields
  activeOrganizationId String?
  activeTeamId         String?

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@index([identifier])
  @@map("verification")
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([secret])
  @@index([userId])
  @@map("twoFactor")
}

// Organization Plugin Tables

model Organization {
  id          String       @id
  name        String
  slug        String       @unique
  logo        String?
  metadata    String?
  createdAt   DateTime
  members     Member[]
  invitations Invitation[]

  @@map("organization")
}

model Member {
  id             String       @id
  userId         String
  organizationId String
  role           String
  createdAt      DateTime
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
  @@index([organizationId])
  @@index([userId])
  @@map("member")
}

model Invitation {
  id             String       @id
  email          String
  inviterId      String
  organizationId String
  role           String
  status         String
  createdAt      DateTime
  expiresAt      DateTime
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  User           User?        @relation(fields: [userId], references: [id])
  userId         String?

  @@index([organizationId])
  @@index([email])
  @@map("invitation")
}

// ==========================================
// Daymark - Personal Productivity Entities
// ==========================================

// Life Areas - Context filters for organizing life domains
model LifeArea {
  id         String   @id @default(cuid())
  userId     String
  name       String
  color      String?  // Hex color like "#4F46E5"
  order      Int
  isArchived Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  days            Day[]
  eisenhowerTasks EisenhowerTask[]
  decisionEntries DecisionEntry[]

  @@index([userId])
  @@map("life_area")
}

// Core Daymark Entity - One per user per date per life area
model Day {
  id         String    @id @default(cuid())
  date       DateTime  @db.Date
  userId     String
  lifeAreaId String?
  lifeArea   LifeArea? @relation(fields: [lifeAreaId], references: [id], onDelete: SetNull)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  priorities      TopPriority[]
  discussionItems DiscussionItem[]
  timeBlocks      TimeBlock[]
  quickNote       QuickNote?
  dailyReview     DailyReview?

  @@unique([userId, date, lifeAreaId])
  @@index([userId])
  @@index([lifeAreaId])
  @@map("day")
}

model TopPriority {
  id        String   @id @default(cuid())
  title     String
  completed Boolean  @default(false)
  order     Int      // 1, 2, or 3
  dayId     String
  day       Day      @relation(fields: [dayId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Time blocks linked to this priority
  timeBlocks TimeBlock[]

  // Focus Suite v2: Linked decisions
  decisions DecisionEntry[]

  @@index([dayId])
  @@map("top_priority")
}


model DiscussionItem {
  id        String   @id @default(cuid())
  content   String
  order     Int      // 1, 2, or 3
  dayId     String
  day       Day      @relation(fields: [dayId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([dayId])
  @@map("discussion_item")
}

model TimeBlock {
  id        String   @id @default(cuid())
  title     String
  startTime DateTime
  endTime   DateTime
  type      String   @default("Deep Work") // Flexible: Deep Work, Meeting, Personal, or custom
  dayId     String
  day       Day      @relation(fields: [dayId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  isFromCalendar   Boolean @default(false)
  calendarSourceId String?
  externalEventId  String?

  // Priority linking - connect time blocks to priorities/goals
  priorityId String?
  priority   TopPriority? @relation(fields: [priorityId], references: [id], onDelete: SetNull)
  
  // Category for different block types (focus, meeting, break, deep-work, personal)
  category String @default("focus")
  
  // Recurrence support
  recurrenceRule    String?   // RRULE format (e.g., "FREQ=DAILY;BYDAY=MO,TU,WE,TH,FR")
  recurrenceEndDate DateTime?
  parentBlockId     String?   // For recurring instances
  parentBlock       TimeBlock?  @relation("RecurringBlocks", fields: [parentBlockId], references: [id], onDelete: SetNull)
  childBlocks       TimeBlock[] @relation("RecurringBlocks")
  
  // Cross-calendar blocking
  blockExternalCalendars Boolean @default(true) // Whether to push "busy" to external calendars
  
  // Focus sessions tracking
  focusSessions FocusSession[]

  // Focus Suite v2: Matrix tasks scheduled for this block
  eisenhowerTasks EisenhowerTask[]

  @@index([dayId])
  @@index([isFromCalendar])
  @@index([externalEventId])
  @@index([priorityId])
  @@index([category])
  @@index([parentBlockId])
  @@map("time_block")
}

// Focus Session - tracks pomodoro/focus sessions linked to time blocks
model FocusSession {
  id          String     @id @default(cuid())
  timeBlockId String
  timeBlock   TimeBlock  @relation(fields: [timeBlockId], references: [id], onDelete: Cascade)
  
  startedAt   DateTime
  endedAt     DateTime?
  duration    Int?       // Duration in seconds
  
  // Session status
  completed   Boolean    @default(false)
  interrupted Boolean    @default(false)
  
  // Session type (from pomodoro settings)
  sessionType String     @default("focus") // focus, shortBreak, longBreak
  
  // Metrics
  targetDuration Int?    // Expected duration in seconds
  
  createdAt   DateTime   @default(now())
  
  // Focus Suite v2: Linked decisions
  decisions   DecisionFocusSession[]
  
  @@index([timeBlockId])
  @@index([startedAt])
  @@map("focus_session")
}



model QuickNote {
  id        String   @id @default(cuid())
  content   String   @db.Text
  dayId     String   @unique
  day       Day      @relation(fields: [dayId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("quick_note")
}

model DailyReview {
  id          String   @id @default(cuid())
  wentWell    String?  @db.Text
  didntGoWell String?  @db.Text
  dayId       String   @unique
  day         Day      @relation(fields: [dayId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("daily_review")
}

// ==========================================
// User Settings - Dashboard Customization
// ==========================================

model UserSettings {
  id     String @id @default(cuid())
  userId String @unique

  // Dashboard Preferences
  maxTopPriorities   Int @default(3) // 1-5
  maxDiscussionItems Int @default(3) // 0-5

  // Section Visibility (JSON array of enabled section keys)
  // Default: ["priorities", "discussion", "schedule", "notes", "progress", "review"]
  enabledSections String @default("[\"priorities\",\"discussion\",\"schedule\",\"notes\",\"progress\",\"review\"]")

  // Scheduling Preferences
  defaultTimeBlockDuration Int    @default(60) // minutes
  defaultTimeBlockType     String @default("Deep Work")

  // Review Preferences
  endOfDayReviewEnabled Boolean @default(true)

  // Daily Behavior Rules
  autoCarryForward  Boolean @default(true)
  autoCreateNextDay Boolean @default(true)

  // Tools Settings
  toolsTabEnabled      Boolean @default(true)
  pomodoroEnabled      Boolean @default(true)
  eisenhowerEnabled    Boolean @default(true)
  decisionLogEnabled   Boolean @default(true)
  pomodoroFocusDuration    Int @default(25)  // minutes
  pomodoroShortBreak       Int @default(5)   // minutes
  pomodoroLongBreak        Int @default(15)  // minutes
  pomodoroSoundEnabled     Boolean @default(true)  // notification sound

  // Life Areas Settings
  lifeAreasEnabled   Boolean @default(true)
  defaultLifeAreaId  String? // User's preferred default life area

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("user_settings")
}

// ==========================================
// Tools - Eisenhower Matrix
// ==========================================

model EisenhowerTask {
  id         String    @id @default(cuid())
  userId     String
  lifeAreaId String?
  lifeArea   LifeArea? @relation(fields: [lifeAreaId], references: [id], onDelete: SetNull)
  title      String
  note       String?   @db.Text
  quadrant   Int       // 1=Urgent+Important, 2=Not Urgent+Important, 3=Urgent+Not Important, 4=Neither

  // Focus Suite v2: Scheduled focus blocks and promotion
  scheduledTimeBlockId String?
  scheduledTimeBlock   TimeBlock? @relation(fields: [scheduledTimeBlockId], references: [id], onDelete: SetNull)
  promotedDate         DateTime?  // Date when promoted to daily priority
  promotedPriorityId   String?    // Reference to created priority

  // Focus Suite v2: Related decisions
  decisions DecisionEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([lifeAreaId])
  @@index([scheduledTimeBlockId])
  @@map("eisenhower_task")
}

// ==========================================
// Tools - Decision Log
// ==========================================

model DecisionEntry {
  id         String    @id @default(cuid())
  userId     String
  lifeAreaId String?
  lifeArea   LifeArea? @relation(fields: [lifeAreaId], references: [id], onDelete: SetNull)
  title      String
  date       DateTime
  context    String?   @db.Text
  decision   String    @db.Text
  outcome    String?   @db.Text

  // Focus Suite v2: Linkage to related tasks and sessions
  eisenhowerTaskId String?
  eisenhowerTask   EisenhowerTask? @relation(fields: [eisenhowerTaskId], references: [id], onDelete: SetNull)
  priorityId       String?
  priority         TopPriority? @relation(fields: [priorityId], references: [id], onDelete: SetNull)

  // Focus Suite v2: Link to focus sessions that produced this decision
  focusSessions DecisionFocusSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([lifeAreaId])
  @@index([eisenhowerTaskId])
  @@index([priorityId])
  @@map("decision_entry")
}

// Focus Suite v2: Join table for Decision <-> FocusSession many-to-many
model DecisionFocusSession {
  id             String        @id @default(cuid())
  decisionId     String
  decision       DecisionEntry @relation(fields: [decisionId], references: [id], onDelete: Cascade)
  focusSessionId String
  focusSession   FocusSession  @relation(fields: [focusSessionId], references: [id], onDelete: Cascade)
  createdAt      DateTime      @default(now())

  @@unique([decisionId, focusSessionId])
  @@index([decisionId])
  @@index([focusSessionId])
  @@map("decision_focus_session")
}

// ==========================================
// Calendar Sync - Enums
// ==========================================

enum CalendarProvider {
  GOOGLE
  MICROSOFT
  APPLE
}

enum ConnectionStatus {
  DISCONNECTED
  CONNECTING
  INITIAL_SYNC
  ACTIVE
  SYNCING
  PAUSED
  ERROR
  TOKEN_EXPIRED
}

enum SyncDirection {
  READ_ONLY
  WRITE_ONLY
  BIDIRECTIONAL
}

enum PrivacyMode {
  FULL
  BUSY_ONLY
  TITLE_ONLY
}

enum EventSyncStatus {
  SYNCED
  PENDING_INBOUND
  PENDING_OUTBOUND
  CONFLICT
  ERROR
}

enum ConflictStrategy {
  LAST_WRITE_WINS
  SOURCE_PRIORITY
  MANUAL
}

// ==========================================
// Calendar Sync - Models
// ==========================================

model CalendarConnection {
  id                String           @id @default(cuid())
  userId            String
  provider          CalendarProvider
  providerAccountId String
  providerEmail     String?

  status            ConnectionStatus @default(DISCONNECTED)
  errorMessage      String?
  lastErrorAt       DateTime?

  lastSyncAt        DateTime?
  lastSyncDuration  Int?
  syncToken         String?

  webhookChannelId  String?
  webhookSecret     String?
  webhookExpiresAt  DateTime?
  webhookResourceId String?

  enabled           Boolean          @default(true)
  syncIntervalMins  Int              @default(15)

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  token             CalendarToken?
  sources           CalendarSource[]
  conflicts         CalendarConflict[]
  auditLogs         SyncAuditLog[]

  @@unique([userId, provider, providerAccountId])
  @@index([userId])
  @@index([status])
  @@map("calendar_connection")
}

model CalendarToken {
  id                    String             @id @default(cuid())
  connectionId          String             @unique
  connection            CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  accessTokenEncrypted  String             @db.Text
  refreshTokenEncrypted String?            @db.Text
  tokenIv               String

  expiresAt             DateTime?
  scopes                String[]
  tokenType             String             @default("Bearer")

  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  @@index([expiresAt])
  @@map("calendar_token")
}

model CalendarSource {
  id                  String             @id @default(cuid())
  connectionId        String
  connection          CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  externalCalendarId  String
  name                String
  description         String?
  color               String?
  timeZone            String?

  syncEnabled         Boolean            @default(false)
  syncDirection       SyncDirection      @default(BIDIRECTIONAL)
  isPrimary           Boolean            @default(false)

  privacyMode         PrivacyMode        @default(FULL)
  defaultEventType    String             @default("Meeting")
  excludePatterns     String[]

  calendarSyncToken   String?
  lastSyncAt          DateTime?
  eventCount          Int                @default(0)

  // Webhook per source for real-time updates
  webhookChannelId    String?
  webhookResourceId   String?
  webhookExpiresAt    DateTime?

  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt

  eventMappings       EventMapping[]

  @@unique([connectionId, externalCalendarId])
  @@index([connectionId])
  @@index([webhookExpiresAt])
  @@map("calendar_source")
}

model EventMapping {
  id                String          @id @default(cuid())
  calendarSourceId  String
  calendarSource    CalendarSource  @relation(fields: [calendarSourceId], references: [id], onDelete: Cascade)

  externalEventId   String
  externalEtag      String?
  externalUpdatedAt DateTime?

  timeBlockId       String?

  syncStatus        EventSyncStatus @default(SYNCED)
  lastSyncDirection String?
  lastSyncAt        DateTime?
  syncError         String?

  lastKnownTitle    String?
  lastKnownStart    DateTime?
  lastKnownEnd      DateTime?

  // Cross-calendar blocking: tracks if this event was created to block time from another source
  isBlockingEvent      Boolean  @default(false)
  blockedByMappingId   String?  // References the original EventMapping that triggered this block
  blockedByMapping     EventMapping?  @relation("BlockingEvents", fields: [blockedByMappingId], references: [id], onDelete: SetNull)
  blockingEvents       EventMapping[] @relation("BlockingEvents")

  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@unique([calendarSourceId, externalEventId])
  @@index([timeBlockId])
  @@index([syncStatus])
  @@index([blockedByMappingId])
  @@map("event_mapping")
}

model CalendarConflict {
  id              String              @id @default(cuid())
  connectionId    String
  connection      CalendarConnection  @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  conflictType    String

  localEventId    String?
  localTitle      String?
  localStart      DateTime?
  localEnd        DateTime?
  localUpdatedAt  DateTime?

  remoteEventId   String?
  remoteTitle     String?
  remoteStart     DateTime?
  remoteEnd       DateTime?
  remoteUpdatedAt DateTime?

  resolved        Boolean             @default(false)
  resolvedAt      DateTime?
  resolution      String?

  expiresAt       DateTime

  createdAt       DateTime            @default(now())

  @@index([connectionId])
  @@index([resolved])
  @@map("calendar_conflict")
}

model SyncAuditLog {
  id            String              @id @default(cuid())
  connectionId  String
  connection    CalendarConnection  @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  action        String
  status        String

  eventsProcessed Int?
  eventsCreated   Int?
  eventsUpdated   Int?
  eventsDeleted   Int?
  conflictsFound  Int?
  durationMs      Int?

  errorMessage    String?           @db.Text
  metadata        Json?

  createdAt       DateTime          @default(now())

  @@index([connectionId])
  @@index([createdAt])
  @@map("sync_audit_log")
}

model UserCalendarSettings {
  id                    String            @id @default(cuid())
  userId                String            @unique

  defaultSyncDirection  SyncDirection     @default(BIDIRECTIONAL)
  defaultPrivacyMode    PrivacyMode       @default(FULL)
  defaultEventType      String            @default("Meeting")

  conflictStrategy      ConflictStrategy  @default(LAST_WRITE_WINS)
  primaryCalendarId     String?
  notifyOnConflict      Boolean           @default(true)

  syncRangeMonthsPast   Int               @default(1)
  syncRangeMonthsFuture Int               @default(6)

  doubleBookingAlert    Boolean           @default(true)

  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  @@map("user_calendar_settings")
}
